var MoveHere=function(t){"use strict";class i{constructor({x:t=0,y:i=-0,width:e=0,height:n=0}={}){this._x=t,this._y=i,this._width=e,this._height=n,this._halfWidth=e/2,this._halfHeight=n/2,this._eighthWidth=e/8,this._eighthHeight=n/8}set x(t){this._x=t}get x(){return this._x}set y(t){this._y=t}get y(){return this._y}set width(t){this._width=t,this._halfWidth=t/2,this._eighthWidth=t/8}get width(){return this._width}set height(t){this._height=t,this._halfHeight=t/2,this._eighthHeight=t/8}get height(){return this._height}get halfWidth(){return this._halfWidth}get halfHeight(){return this._halfHeight}get eighthWidth(){return this._eighthWidth}get eighthHeight(){return this._eighthHeight}}const e=Object.defineProperties({},{CURVE_RANDOM:{enumerable:!0,value:"curveRandom"}}),n=Math.PI/180,s=180/Math.PI;class o{static radians(t){return n*t}static degrees(t){return s*t}static normalizeAngle(t){if(t>360)for(;t>360;)t-=360;else if(t<-360)for(;t<-360;)t+=360;return t}static getMinAngleDiff(t,i){if(t<=0&&i>=0||t>=0&&i<=0){const e=t>0?t:-t,n=i>0?i:-i,s=180-e,o=180-n;return Math.min(s+o,e+n)}const e=t-i;return e>0?e:-e}static convertRotationToAngle(t,i,e){let n;return n=i>=0&&e<0?90+t:i>=0&&e>=0?t-90:i<0&&e>=0?t+270:t+90,o.normalizeAngle(n)}static convertAngleToRotation(t,i,e){let n;return n=i>=0&&e<0?90-t:i>=0&&e>=0?90+t:i<0&&e>=0?-270+t:90-t}static distanceBetweenTwoPoints(t,i,e,n){return Math.sqrt((t-e)*(t-e)+(i-n)*(i-n))}static getRandomPointInsideRect(t,i,e=!0){const n={min:0,max:0},s={min:0,max:0},o={x:0,y:0};return e?(t.x<i.x+i.halfWidth?(n.min=i.eighthWidth,n.max=i.halfWidth-n.min):(n.min=-i.eighthWidth,n.max=-i.halfWidth-n.min),t.y<i.y+i.halfHeight?(s.min=i.eighthHeight,s.max=i.halfHeight-s.min):(s.min=-i.eighthHeight,s.max=-i.halfHeight-s.min)):(n.min=i.x,n.max=i.width,s.min=i.y,s.max=i.height),o.x=t.x+Math.round(n.min+Math.random()*n.max),o.y=t.y+Math.round(s.min+Math.random()*s.max),o.x>i.x+i.width?o.x=i.x+i.width:o.x<i.x&&(o.x=i.x),o.y>i.y+i.height?o.y=i.y+i.height:o.y<i.y&&(o.y=i.y),o}static getRandomPointOutsideRect(t,i){const e={x:0,y:0};switch(Math.floor(4*Math.random())){case 0:e.x=i.x-t.width,e.y=i.y+Math.round(Math.random()*i.height);break;case 1:e.x=i.x+Math.round(Math.random()*i.width),e.y=i.y-t.height;break;case 2:e.x=i.x+i.width+t.width,e.y=i.y+Math.round(Math.random()*i.height);break;case 3:e.x=i.x+Math.round(Math.random()*i.width),e.y=i.y+i.height+t.height}return e}}var r=Object.freeze({BORN:"born",ALIVE:"alive",DYING:"dying",DEAD:"dead"});const a="inside",h=function(t){const i={};return i.x=t.destinationX-t.x,i.y=t.destinationY-t.y,i},u=function(t,i,e){let n;n=e===a?o.getRandomPointInsideRect(t,i):o.getRandomPointOutsideRect(t,i),t.destinationX=n.x,t.destinationY=n.y},d=function(t){t.acquireRotationDirection=!0,t.rotationAmount=0},c=function(t,i,e){t.status===r.ALIVE&&-1!==t.duration&&i-t.initTime>=t.duration&&(u(t,e,"outside"),d(t),t.status=r.DYING)},g=function(t,i){if(t.simulateDepth){let e=.5+(t.y-i.y)/i.height*1;e<.5&&(e=.5),e>1.5&&(e=1.5),t.scaleX=e,t.scaleY=e}},_=function(t,i){const e=o.distanceBetweenTwoPoints(t.x,t.y,t.destinationX,t.destinationY);if(0===e)return;let n=t.rotation;const s=Math.round(o.degrees(Math.acos(i.x/e))),r=o.convertAngleToRotation(s,i.x,i.y);if(o.getMinAngleDiff(r,n)<=t.rotationPerFrame)n=r;else{t.acquireRotationDirection&&(t.acquireRotationDirection=!1,t.rotationDirection=s<n?-1:1);const i=t.rotationAmount/360<=1?1:t.rotationAmount/360;n+=t.rotationDirection*t.rotationPerFrame*i,n=o.normalizeAngle(n)}t.rotationAmount+=o.getMinAngleDiff(t.rotation,n),t.rotation=n},m=function(t,i){if(Math.abs(i.x)<t.unitsPerFrame&&Math.abs(i.y)<t.unitsPerFrame)t.status===r.DYING&&(t.status=r.DEAD),t.x=t.destinationX,t.y=t.destinationY;else{const e=o.radians(o.convertRotationToAngle(t.rotation,i.x,i.y));i.y<0?(t.x-=Math.cos(e)*t.unitsPerFrame,t.y-=Math.sin(e)*t.unitsPerFrame):(t.x+=Math.cos(e)*t.unitsPerFrame,t.y+=Math.sin(e)*t.unitsPerFrame)}},l=function(t){return t.x===t.destinationX&&t.y===t.destinationY};class x{constructor(t){this._boundingRectangle=t,this._motionAssets={}}addAsset(t){let i;i="inside"===t.spawnLocation?o.getRandomPointInsideRect(t,t.boundingRectangle||this._boundingRectangle,!1):o.getRandomPointOutsideRect(t,t.boundingRectangle||this._boundingRectangle),t.x=i.x,t.y=i.y,u(t,t.boundingRectangle||this._boundingRectangle,a),d(t),g(t,this._boundingRectangle),t.status=r.ALIVE,this._motionAssets[t.id]=t}update(t){let i,e;Object.keys(this._motionAssets).forEach(n=>{i=this._motionAssets[n],c(i,t,i.boundingRectangle||this._boundingRectangle),e=h(i),g(i,this._boundingRectangle),_(i,e),m(i,e),l(i)&&(u(i,i.boundingRectangle||this._boundingRectangle,a),d(i)),i.status===r.DEAD&&delete this._motionAssets[n]})}}class y{constructor(){this._requestAnimationId=null,this._paused=!0,this._currentTime=0,this._lastTime=0,this._timeInMilliseconds=0,this._timeUpdateHandlers=[]}_tick(){this._requestAnimationId=null,this._currentTime=performance.now(),this._timeInMilliseconds+=this._currentTime-this._lastTime,this._lastTime=this._currentTime,this._timeUpdateHandlers.every(t=>t(this._timeInMilliseconds)),this._paused||(this._requestAnimationId=requestAnimationFrame(()=>this._tick()))}get paused(){return this._paused}get time(){return this._timeInMilliseconds}addTimeUpdateListener(t){this._timeUpdateHandlers.push(t)}play(){this._paused=!1,this._lastTime=performance.now(),this._requestAnimationId=requestAnimationFrame(()=>this._tick())}pause(){this._requestAnimationId&&(cancelAnimationFrame(this._requestAnimationId),this._requestAnimationId=null),this._paused=!0}}let R=0;class D{static getId(){return R++}}const f=60,p=1;class M{constructor(t,i,e,n,s,o,a,h,u,d=null){this._id=D.getId(),this._target=t,this._initTimeInMilliseconds=i,this._duration=e,this._unitsPerSecond=n,this._rotationPerSecond=s,this._rotationPerFrame=s/f,this._motionDirection=o,this._rotateToDirection=a,this._unitsPerFrame=n/f,this._simulateDepth=h,this._spawnLocation=u,this._acquireRotationDirection=!1,this._destinationX=0,this._destinationY=0,this._status=r.BORN,this._rotationAmount=0,this._rotationDirection=1,this._rotationProxy=0,this._boundingRectangle=d,this._rotationPerFrame<p&&(this._rotationPerFrame=p)}get id(){return this._id}get target(){return this._target}get duration(){return this._duration}get unitsPerSecond(){return this._unitsPerSecond}get unitsPerFrame(){return this._unitsPerFrame}set status(t){this._status=t}get status(){return this._status}set initTime(t){this._initTimeInMilliseconds=t}get initTime(){return this._initTimeInMilliseconds}set x(t){this._target.x=t}get x(){return this._target.x}set y(t){this._target.y=t}get y(){return this._target.y}get width(){return this._target.width||0}get height(){return this._target.height||0}set rotation(t){this._rotateToDirection?this._target.rotation=t:this._rotationProxy=t}get rotation(){return this._rotateToDirection?this._target.rotation:this._rotationProxy}set destinationX(t){this._destinationX=t}get destinationX(){return this._destinationX}set destinationY(t){this._destinationY=t}get destinationY(){return this._destinationY}get rotationPerSecond(){return this._rotationPerSecond}get rotationPerFrame(){return this._rotationPerFrame}get motionDirection(){return this._motionDirection}set rotateToDirection(t){this._rotateToDirection=t}get rotateToDirection(){return this._rotateToDirection}set acquireRotationDirection(t){this._acquireRotationDirection=t}get acquireRotationDirection(){return this._acquireRotationDirection}set rotationAmount(t){this._rotationAmount=t}get rotationAmount(){return this._rotationAmount}set rotationDirection(t){this._rotationDirection=t}get rotationDirection(){return this._rotationDirection}set simulateDepth(t){this._simulateDepth=t}get simulateDepth(){return this._simulateDepth}set spawnLocation(t){this._spawnLocation=t}get spawnLocation(){return this._spawnLocation}get boundingRectangle(){return this._boundingRectangle}}const A=2e3,w=30,P=1;return t.MotionDirection=e,t.Rectangle=i,t.MotionEngine=class{constructor(t=new i){this._boundingRectangle=t,this._timer=new y,this._adaptersMap={};const n=new x(this._boundingRectangle);this._timer.addTimeUpdateListener(n.update.bind(n)),this._adaptersMap[e.CURVE_RANDOM]=n}get paused(){return this._timer.paused}start(){this._timer.play()}stop(){this._timer.pause()}addAsset({target:t=null,motionDirection:i=e.CURVE_RANDOM,duration:n=A,unitsPerSecond:s=w,rotationSpeedModifier:o=P,rotateToDirection:r=!0,simulateDepth:a=!1,spawnLocation:h="outside"}={}){const u=this._adaptersMap[i];if(!u)throw new Error(`MotionEngine - No motion adapter found with supplied motion direction of (${i})`);const d=Math.round(s*o),c=new M(t,this._timer.time,n,s,d,i,r,a,h);return u.addAsset(c),c}},t}({});
//# sourceMappingURL=move-here.min.js.map
