class t{constructor({x:t=0,y:i=-0,width:e=0,height:n=0}={}){this._x=t,this._y=i,this._width=e,this._height=n,this._halfWidth=e/2,this._halfHeight=n/2,this._eighthWidth=e/8,this._eighthHeight=n/8}set x(t){this._x=t}get x(){return this._x}set y(t){this._y=t}get y(){return this._y}set width(t){this._width=t,this._halfWidth=t/2,this._eighthWidth=t/8}get width(){return this._width}set height(t){this._height=t,this._halfHeight=t/2,this._eighthHeight=t/8}get height(){return this._height}get halfWidth(){return this._halfWidth}get halfHeight(){return this._halfHeight}get eighthWidth(){return this._eighthWidth}get eighthHeight(){return this._eighthHeight}}const i=Object.defineProperties({},{CURVE_RANDOM:{enumerable:!0,value:"curveRandom"}}),e=Math.PI/180,n=180/Math.PI;class s{static radians(t){return e*t}static degrees(t){return n*t}static normalizeAngle(t){if(t>360)for(;t>360;)t-=360;else if(t<-360)for(;t<-360;)t+=360;return t}static getMinAngleDiff(t,i){if(t<=0&&i>=0||t>=0&&i<=0){const e=t>0?t:-t,n=i>0?i:-i,s=180-e,o=180-n;return Math.min(s+o,e+n)}const e=t-i;return e>0?e:-e}static convertRotationToAngle(t,i,e){let n;return n=i>=0&&e<0?90+t:i>=0&&e>=0?t-90:i<0&&e>=0?t+270:t+90,s.normalizeAngle(n)}static convertAngleToRotation(t,i,e){let n;return n=i>=0&&e<0?90-t:i>=0&&e>=0?90+t:i<0&&e>=0?-270+t:90-t}static distanceBetweenTwoPoints(t,i,e,n){return Math.sqrt((t-e)*(t-e)+(i-n)*(i-n))}static getRandomPointInsideRect(t,i,e=!0){const n={min:0,max:0},s={min:0,max:0},o={x:0,y:0};return e?(t.x<i.x+i.halfWidth?(n.min=i.eighthWidth,n.max=i.halfWidth-n.min):(n.min=-i.eighthWidth,n.max=-i.halfWidth-n.min),t.y<i.y+i.halfHeight?(s.min=i.eighthHeight,s.max=i.halfHeight-s.min):(s.min=-i.eighthHeight,s.max=-i.halfHeight-s.min)):(n.min=i.x,n.max=i.width,s.min=i.y,s.max=i.height),o.x=t.x+Math.round(n.min+Math.random()*n.max),o.y=t.y+Math.round(s.min+Math.random()*s.max),o.x>i.x+i.width?o.x=i.x+i.width:o.x<i.x&&(o.x=i.x),o.y>i.y+i.height?o.y=i.y+i.height:o.y<i.y&&(o.y=i.y),o}static getRandomPointOutsideRect(t,i){const e={x:0,y:0};switch(Math.floor(4*Math.random())){case 0:e.x=i.x-t.width,e.y=i.y+Math.round(Math.random()*i.height);break;case 1:e.x=i.x+Math.round(Math.random()*i.width),e.y=i.y-t.height;break;case 2:e.x=i.x+i.width+t.width,e.y=i.y+Math.round(Math.random()*i.height);break;case 3:e.x=i.x+Math.round(Math.random()*i.width),e.y=i.y+i.height+t.height}return e}}var o=Object.freeze({BORN:"born",ALIVE:"alive",DYING:"dying",DEAD:"dead"});const r="inside",a=function(t){const i={};return i.x=t.destinationX-t.x,i.y=t.destinationY-t.y,i},h=function(t,i,e){let n;n=e===r?s.getRandomPointInsideRect(t,i):s.getRandomPointOutsideRect(t,i),t.destinationX=n.x,t.destinationY=n.y},u=function(t){t.acquireRotationDirection=!0,t.rotationAmount=0},d=function(t,i,e){t.status===o.ALIVE&&-1!==t.duration&&i-t.initTime>=t.duration&&(h(t,e,"outside"),u(t),t.status=o.DYING)},c=function(t,i){if(t.simulateDepth){let e=.5+(t.y-i.y)/i.height*1;e<.5&&(e=.5),e>1.5&&(e=1.5),t.scaleX=e,t.scaleY=e}},g=function(t,i){const e=s.distanceBetweenTwoPoints(t.x,t.y,t.destinationX,t.destinationY);if(0===e)return;let n=t.rotation;const o=Math.round(s.degrees(Math.acos(i.x/e))),r=s.convertAngleToRotation(o,i.x,i.y);if(s.getMinAngleDiff(r,n)<=t.rotationPerFrame)n=r;else{t.acquireRotationDirection&&(t.acquireRotationDirection=!1,t.rotationDirection=o<n?-1:1);const i=t.rotationAmount/360<=1?1:t.rotationAmount/360;n+=t.rotationDirection*t.rotationPerFrame*i,n=s.normalizeAngle(n)}t.rotationAmount+=s.getMinAngleDiff(t.rotation,n),t.rotation=n},_=function(t,i){if(Math.abs(i.x)<t.unitsPerFrame&&Math.abs(i.y)<t.unitsPerFrame)t.status===o.DYING&&(t.status=o.DEAD),t.x=t.destinationX,t.y=t.destinationY;else{const e=s.radians(s.convertRotationToAngle(t.rotation,i.x,i.y));i.y<0?(t.x-=Math.cos(e)*t.unitsPerFrame,t.y-=Math.sin(e)*t.unitsPerFrame):(t.x+=Math.cos(e)*t.unitsPerFrame,t.y+=Math.sin(e)*t.unitsPerFrame)}},m=function(t){return t.x===t.destinationX&&t.y===t.destinationY};class l{constructor(t){this._boundingRectangle=t,this._motionAssets={}}addAsset(t){let i;i="inside"===t.spawnLocation?s.getRandomPointInsideRect(t,t.boundingRectangle||this._boundingRectangle,!1):s.getRandomPointOutsideRect(t,t.boundingRectangle||this._boundingRectangle),t.x=i.x,t.y=i.y,h(t,t.boundingRectangle||this._boundingRectangle,r),u(t),c(t,this._boundingRectangle),t.status=o.ALIVE,this._motionAssets[t.id]=t}update(t){let i,e;Object.keys(this._motionAssets).forEach(n=>{i=this._motionAssets[n],d(i,t,i.boundingRectangle||this._boundingRectangle),e=a(i),c(i,this._boundingRectangle),g(i,e),_(i,e),m(i)&&(h(i,i.boundingRectangle||this._boundingRectangle,r),u(i)),i.status===o.DEAD&&delete this._motionAssets[n]})}}class x{constructor(){this._requestAnimationId=null,this._paused=!0,this._currentTime=0,this._lastTime=0,this._timeInMilliseconds=0,this._timeUpdateHandlers=[]}_tick(){this._requestAnimationId=null,this._currentTime=performance.now(),this._timeInMilliseconds+=this._currentTime-this._lastTime,this._lastTime=this._currentTime,this._timeUpdateHandlers.every(t=>t(this._timeInMilliseconds)),this._paused||(this._requestAnimationId=requestAnimationFrame(()=>this._tick()))}get paused(){return this._paused}get time(){return this._timeInMilliseconds}addTimeUpdateListener(t){this._timeUpdateHandlers.push(t)}play(){this._paused=!1,this._lastTime=performance.now(),this._requestAnimationId=requestAnimationFrame(()=>this._tick())}pause(){this._requestAnimationId&&(cancelAnimationFrame(this._requestAnimationId),this._requestAnimationId=null),this._paused=!0}}let y=0;class R{static getId(){return y++}}const p=60,D=1;class f{constructor(t,i,e,n,s,r,a,h,u,d=null){this._id=R.getId(),this._target=t,this._initTimeInMilliseconds=i,this._duration=e,this._unitsPerSecond=n,this._rotationPerSecond=s,this._rotationPerFrame=s/p,this._motionDirection=r,this._rotateToDirection=a,this._unitsPerFrame=n/p,this._simulateDepth=h,this._spawnLocation=u,this._acquireRotationDirection=!1,this._destinationX=0,this._destinationY=0,this._status=o.BORN,this._rotationAmount=0,this._rotationDirection=1,this._rotationProxy=0,this._boundingRectangle=d,this._rotationPerFrame<D&&(this._rotationPerFrame=D)}get id(){return this._id}get target(){return this._target}get duration(){return this._duration}get unitsPerSecond(){return this._unitsPerSecond}get unitsPerFrame(){return this._unitsPerFrame}set status(t){this._status=t}get status(){return this._status}set initTime(t){this._initTimeInMilliseconds=t}get initTime(){return this._initTimeInMilliseconds}set x(t){this._target.x=t}get x(){return this._target.x}set y(t){this._target.y=t}get y(){return this._target.y}get width(){return this._target.width||0}get height(){return this._target.height||0}set rotation(t){this._rotateToDirection?this._target.rotation=t:this._rotationProxy=t}get rotation(){return this._rotateToDirection?this._target.rotation:this._rotationProxy}set destinationX(t){this._destinationX=t}get destinationX(){return this._destinationX}set destinationY(t){this._destinationY=t}get destinationY(){return this._destinationY}get rotationPerSecond(){return this._rotationPerSecond}get rotationPerFrame(){return this._rotationPerFrame}get motionDirection(){return this._motionDirection}set rotateToDirection(t){this._rotateToDirection=t}get rotateToDirection(){return this._rotateToDirection}set acquireRotationDirection(t){this._acquireRotationDirection=t}get acquireRotationDirection(){return this._acquireRotationDirection}set rotationAmount(t){this._rotationAmount=t}get rotationAmount(){return this._rotationAmount}set rotationDirection(t){this._rotationDirection=t}get rotationDirection(){return this._rotationDirection}set simulateDepth(t){this._simulateDepth=t}get simulateDepth(){return this._simulateDepth}set spawnLocation(t){this._spawnLocation=t}get spawnLocation(){return this._spawnLocation}get boundingRectangle(){return this._boundingRectangle}}const A=2e3,M=30,w=1;class P{constructor(e=new t){this._boundingRectangle=e,this._timer=new x,this._adaptersMap={};const n=new l(this._boundingRectangle);this._timer.addTimeUpdateListener(n.update.bind(n)),this._adaptersMap[i.CURVE_RANDOM]=n}get paused(){return this._timer.paused}start(){this._timer.play()}stop(){this._timer.pause()}addAsset({target:t=null,motionDirection:e=i.CURVE_RANDOM,duration:n=A,unitsPerSecond:s=M,rotationSpeedModifier:o=w,rotateToDirection:r=!0,simulateDepth:a=!1,spawnLocation:h="outside",boundingRectangle:u=null}={}){const d=this._adaptersMap[e];if(!d)throw new Error(`MotionEngine - No motion adapter found with supplied motion direction of (${e})`);const c=Math.round(s*o),g=new f(t,this._timer.time,n,s,c,e,r,a,h,u);return d.addAsset(g),g}}export{i as MotionDirection,t as Rectangle,P as MotionEngine};
//# sourceMappingURL=move-here.min.mjs.map
