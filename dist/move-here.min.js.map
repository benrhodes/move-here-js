{"version":3,"file":"move-here.min.js","sources":["../src/rectangle.js","../src/motion-direction.js","../src/mathy.js","../src/status-constants.js","../src/motion-adapters/random-motion-adapter.js","../src/timer.js","../src/id-generator.js","../src/motion-asset.js","../src/motion-engine.js"],"sourcesContent":["export default class Rectangle {\n   constructor({x = 0, y = -0, width = 0, height = 0} = {}) {\n      this._x = x;\n      this._y = y;\n      this._width = width;\n      this._height = height;\n      this._halfWidth = width / 2;\n      this._halfHeight = height / 2;\n      this._eighthWidth = width / 8;\n      this._eighthHeight = height / 8;\n   }\n\n   set x(value) {\n      this._x = value;\n   }\n\n   get x() {\n      return this._x;\n   }\n\n   set y(value) {\n      this._y = value;\n   }\n\n   get y() {\n      return this._y;\n   }\n\n   set width(value) {\n      this._width = value;\n      this._halfWidth = value / 2;\n      this._eighthWidth = value / 8;\n   }\n\n   get width() {\n      return this._width;\n   }\n\n   set height(value) {\n      this._height = value;\n      this._halfHeight = value / 2;\n      this._eighthHeight = value / 8;\n   }\n\n   get height() {\n      return this._height;\n   }\n\n   get halfWidth() {\n      return this._halfWidth;\n   }\n\n   get halfHeight() {\n      return this._halfHeight;\n   }\n\n   get eighthWidth() {\n      return this._eighthWidth;\n   }\n\n   get eighthHeight() {\n      return this._eighthHeight;\n   }\n}","export const MotionDirection = Object.defineProperties({}, {\n   CURVE_RANDOM: {\n      enumerable: true,\n      value: 'curveRandom'\n   }\n});","const RADIANS_CONVERSION = Math.PI / 180;\nconst DEGREES_CONVERSION = 180 / Math.PI;\n\nexport default class Mathy {\n   static radians(degrees) {\n      return RADIANS_CONVERSION * degrees;\n   }\n   static degrees(radians) {\n      return DEGREES_CONVERSION * radians;\n   }\n   static normalizeAngle(angleInDegrees) {\n      if (angleInDegrees > 360) {\n         while (angleInDegrees > 360) {\n            angleInDegrees -= 360;\n         }\n      } else if (angleInDegrees < -360) {\n         while (angleInDegrees < -360) {\n            angleInDegrees += 360;\n         }\n      }\n      return angleInDegrees;\n   }\n   static getMinAngleDiff(angleInDegrees1, angleInDegrees2) {\n      if (angleInDegrees1 <= 0 && angleInDegrees2 >= 0 || angleInDegrees1 >= 0 && angleInDegrees2 <= 0) {\n         const angle1Abs = angleInDegrees1 > 0.0 ? angleInDegrees1 : -angleInDegrees1;\n         const angle2Abs = angleInDegrees2 > 0.0 ? angleInDegrees2 : -angleInDegrees2;\n         const angle1Remainder = 180 - angle1Abs;\n         const angle2Remainder = 180 - angle2Abs;\n         return Math.min(angle1Remainder + angle2Remainder, angle1Abs + angle2Abs);\n      }\n      const rotationDiff = angleInDegrees1 - angleInDegrees2;\n      return rotationDiff > 0.0 ? rotationDiff : -rotationDiff;\n   }\n   static convertRotationToAngle(rotation, xDiff, yDiff) {\n      let currentAngle;\n\n      // Quad 1\n      if (xDiff >= 0 && yDiff < 0) {\n         currentAngle = 90 + rotation;\n         // Quad 2\n      } else if (xDiff >= 0 && yDiff >= 0) {\n         currentAngle = rotation - 90;\n         // Quad 3\n      } else if (xDiff < 0 && yDiff >= 0) {\n         currentAngle = rotation + 270;\n         // Quad 4\n      } else {\n         currentAngle = rotation + 90;\n      }\n\n      return Mathy.normalizeAngle(currentAngle);\n   }\n   static convertAngleToRotation(angle, xDiff, yDiff) {\n      let rotation;\n\n      // Quad 1\n      if (xDiff >= 0 && yDiff < 0) {\n         rotation = 90 - angle;\n         // Quad 2\n      } else if (xDiff >= 0 && yDiff >= 0) {\n         rotation = 90 + angle;\n         // Quad 3\n      } else if (xDiff < 0 && yDiff >= 0) {\n         rotation = -270 + angle;\n         // Quad 4\n      } else {\n         rotation = 90 - angle;\n      }\n\n      return rotation;\n   }\n   static distanceBetweenTwoPoints(x1, y1, x2, y2) {\n      return Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));\n   }\n   static getRandomPointInsideRect(motionAsset, rect, uniqueQuad = true) {\n      const randomXRange = {min: 0, max: 0};\n      const randomYRange = {min: 0, max: 0};\n      const point = {x: 0, y: 0};\n\n      if (uniqueQuad) {\n         if (motionAsset.x < rect.x + rect.halfWidth) {\n            randomXRange.min = rect.eighthWidth;\n            randomXRange.max = rect.halfWidth - randomXRange.min;\n         } else {\n            randomXRange.min = -rect.eighthWidth;\n            randomXRange.max = -rect.halfWidth - randomXRange.min;\n         }\n\n         if (motionAsset.y < rect.y + rect.halfHeight) {\n            randomYRange.min = rect.eighthHeight;\n            randomYRange.max = rect.halfHeight - randomYRange.min;\n         } else {\n            randomYRange.min = -rect.eighthHeight;\n            randomYRange.max = -rect.halfHeight - randomYRange.min;\n         }\n      } else {\n         randomXRange.min = rect.x;\n         randomXRange.max = rect.width;\n         randomYRange.min = rect.y;\n         randomYRange.max = rect.height;\n      }\n\n      point.x = motionAsset.x + Math.round(randomXRange.min + Math.random() * randomXRange.max);\n      point.y = motionAsset.y + Math.round(randomYRange.min + Math.random() * randomYRange.max);\n\n      if (point.x > rect.x + rect.width) {\n         point.x = rect.x + rect.width;\n      } else if (point.x < rect.x) {\n         point.x = rect.x;\n      }\n\n      if (point.y > rect.y + rect.height) {\n         point.y = rect.y + rect.height;\n      } else if (point.y < rect.y) {\n         point.y = rect.y;\n      }\n\n      return point;\n   }\n   static getRandomPointOutsideRect(motionAsset, rect) {\n      const point = {x: 0, y: 0};\n      const region = Math.floor(Math.random() * 4);\n      switch (region) {\n         case 0:\n            point.x = rect.x - motionAsset.width;\n            point.y = rect.y + Math.round(Math.random() * rect.height);\n            break;\n         case 1:\n            point.x = rect.x + Math.round(Math.random() * rect.width);\n            point.y = rect.y - motionAsset.height;\n            break;\n         case 2:\n            point.x = rect.x + rect.width + motionAsset.width;\n            point.y = rect.y + Math.round(Math.random() * rect.height);\n            break;\n         case 3:\n            point.x = rect.x + Math.round(Math.random() * rect.width);\n            point.y = rect.y + rect.height + motionAsset.height;\n            break;\n         default:\n            break;\n      }\n\n      return point;\n   }\n}","export default Object.freeze({\n   BORN: 'born',\n   ALIVE: 'alive',\n   DYING: 'dying',\n   DEAD: 'dead'\n});","const OUTSIDE_TARGET_AREA = 'outside';\nconst INSIDE_TARGET_AREA = 'inside';\nconst MIN_SCALE = .5;\nconst MAX_SCALE = 1.5;\n\nimport Mathy from '../mathy';\nimport Status from '../status-constants';\n\nconst getPositionDelta = function(motionAsset) {\n   const positionDelta = {};\n   positionDelta.x = motionAsset.destinationX - motionAsset.x;\n   positionDelta.y = motionAsset.destinationY - motionAsset.y;\n   return positionDelta;\n};\n\nconst setNewDestinationPoint = function(motionAsset, boundingRectangle, location) {\n   let destinationPoint;\n   if (location === INSIDE_TARGET_AREA) {\n      destinationPoint = Mathy.getRandomPointInsideRect(motionAsset, boundingRectangle);\n   } else {\n      destinationPoint = Mathy.getRandomPointOutsideRect(motionAsset, boundingRectangle);\n   }\n\n   motionAsset.destinationX = destinationPoint.x;\n   motionAsset.destinationY = destinationPoint.y;\n};\n\nconst resetRotationDirection = function(motionAsset) {\n   motionAsset.acquireRotationDirection = true;\n   motionAsset.rotationAmount = 0;\n};\n\nconst setAssetStateBasedOnTime = function(motionAsset, timeInMilliseconds, boundingRectangle) {\n   if (motionAsset.status === Status.ALIVE && motionAsset.duration !== -1 && timeInMilliseconds - motionAsset.initTime >= motionAsset.duration) {\n      setNewDestinationPoint(motionAsset, boundingRectangle, OUTSIDE_TARGET_AREA);\n      resetRotationDirection(motionAsset);\n      motionAsset.status = Status.DYING;\n   }\n};\n\nconst setScale = function(motionAsset, boundingRectangle) {\n   if (motionAsset.simulateDepth) {\n      let newScale = MIN_SCALE + (motionAsset.y - boundingRectangle.y) / boundingRectangle.height * (MAX_SCALE - MIN_SCALE);\n\n      if (newScale < MIN_SCALE) {\n         newScale = MIN_SCALE;\n      }\n      if (newScale > MAX_SCALE) {\n         newScale = MAX_SCALE;\n      }\n\n      motionAsset.scaleX = newScale;\n      motionAsset.scaleY = newScale;\n   }\n};\n\nconst setRotation = function(motionAsset, positionDelta) {\n   const distance = Mathy.distanceBetweenTwoPoints(motionAsset.x, motionAsset.y, motionAsset.destinationX, motionAsset.destinationY);\n   if (distance === 0) {\n      return;\n   }\n   let nextRotation = motionAsset.rotation;\n   const calculatedAngle = Math.round(Mathy.degrees(Math.acos(positionDelta.x / distance)));\n   const calculatedRotation = Mathy.convertAngleToRotation(calculatedAngle, positionDelta.x, positionDelta.y);\n   const rotationDiff = Mathy.getMinAngleDiff(calculatedRotation, nextRotation);\n\n   if (rotationDiff <= motionAsset.rotationPerFrame) {\n      nextRotation = calculatedRotation;\n   } else {\n      if (motionAsset.acquireRotationDirection) {\n         motionAsset.acquireRotationDirection = false;\n         if (calculatedAngle < nextRotation) {\n            motionAsset.rotationDirection = -1;\n         } else {\n            motionAsset.rotationDirection = 1;\n         }\n      }\n\n      // determine rotation modifier, this only comes into play when an object has rotated more than\n      // 360 degrees around the destination point.  We need to increase the speed of rotation to it\n      // so it can reach its destination eventually.\n      const rotationModifier = motionAsset.rotationAmount / 360 <= 1 ? 1 : motionAsset.rotationAmount / 360;\n\n      nextRotation += motionAsset.rotationDirection * motionAsset.rotationPerFrame * rotationModifier;\n      nextRotation = Mathy.normalizeAngle(nextRotation);\n   }\n   motionAsset.rotationAmount += Mathy.getMinAngleDiff(motionAsset.rotation, nextRotation);\n   motionAsset.rotation = nextRotation;\n};\n\nconst setTranslation = function(motionAsset, positionDelta) {\n   if (Math.abs(positionDelta.x) < motionAsset.unitsPerFrame && Math.abs(positionDelta.y) < motionAsset.unitsPerFrame) {\n      if (motionAsset.status === Status.DYING) {\n         motionAsset.status = Status.DEAD;\n      }\n      motionAsset.x = motionAsset.destinationX;\n      motionAsset.y = motionAsset.destinationY;\n   } else {\n      const currentAngleRadians = Mathy.radians(Mathy.convertRotationToAngle(motionAsset.rotation, positionDelta.x, positionDelta.y));\n      if (positionDelta.y < 0) {\n         motionAsset.x -= Math.cos(currentAngleRadians) * motionAsset.unitsPerFrame;\n         motionAsset.y -= Math.sin(currentAngleRadians) * motionAsset.unitsPerFrame;\n      } else {\n         motionAsset.x += Math.cos(currentAngleRadians) * motionAsset.unitsPerFrame;\n         motionAsset.y += Math.sin(currentAngleRadians) * motionAsset.unitsPerFrame;\n      }\n   }\n};\n\nconst doesAssetNeedNewDestinationPoint = function(motionAsset) {\n   return motionAsset.x === motionAsset.destinationX && motionAsset.y === motionAsset.destinationY;\n};\n\nexport default class RandomMotionAdapter {\n   constructor(boundingRectangle) {\n      this._boundingRectangle = boundingRectangle;\n      this._motionAssets = {};\n   }\n   addAsset(motionAsset) {\n      let initPoint;\n      if (motionAsset.spawnLocation === 'inside') {\n         initPoint = Mathy.getRandomPointInsideRect(motionAsset, motionAsset.boundingRectangle || this._boundingRectangle, false);\n      } else {\n         initPoint = Mathy.getRandomPointOutsideRect(motionAsset, motionAsset.boundingRectangle || this._boundingRectangle);\n      }\n      motionAsset.x = initPoint.x;\n      motionAsset.y = initPoint.y;\n\n      setNewDestinationPoint(motionAsset, motionAsset.boundingRectangle || this._boundingRectangle, INSIDE_TARGET_AREA);\n      resetRotationDirection(motionAsset);\n      setScale(motionAsset, this._boundingRectangle);\n\n      motionAsset.status = Status.ALIVE;\n\n      this._motionAssets[motionAsset.id] = motionAsset;\n   }\n   update(timeInMilliseconds) {\n      let motionAsset;\n      let positionDelta;\n\n      Object.keys(this._motionAssets).forEach((key) => {\n         motionAsset = this._motionAssets[key];\n\n         setAssetStateBasedOnTime(motionAsset, timeInMilliseconds, motionAsset.boundingRectangle || this._boundingRectangle);\n\n         positionDelta = getPositionDelta(motionAsset);\n         setScale(motionAsset, this._boundingRectangle);\n         setRotation(motionAsset, positionDelta);\n         setTranslation(motionAsset, positionDelta);\n\n         if (doesAssetNeedNewDestinationPoint(motionAsset)) {\n            setNewDestinationPoint(motionAsset, motionAsset.boundingRectangle || this._boundingRectangle, INSIDE_TARGET_AREA);\n            resetRotationDirection(motionAsset);\n         }\n\n         if (motionAsset.status === Status.DEAD) {\n            delete this._motionAssets[key];\n         }\n      });\n   }\n}\n","export default class Timer {\n   constructor() {\n      this._requestAnimationId = null;\n      this._paused = true;\n      this._currentTime = 0;\n      this._lastTime = 0;\n      this._timeInMilliseconds = 0;\n      this._timeUpdateHandlers = [];\n   }\n   _tick() {\n      this._requestAnimationId = null;\n      this._currentTime = performance.now();\n      this._timeInMilliseconds += this._currentTime - this._lastTime;\n      this._lastTime = this._currentTime;\n      this._timeUpdateHandlers.every((timeUpdateHandler) => {\n         return timeUpdateHandler(this._timeInMilliseconds);\n      });\n      if (!this._paused) {\n         this._requestAnimationId = requestAnimationFrame(() => this._tick());\n      }\n   }\n   get paused() {\n      return this._paused;\n   }\n   get time() {\n      return this._timeInMilliseconds;\n   }\n   addTimeUpdateListener(eventHandler) {\n      this._timeUpdateHandlers.push(eventHandler);\n   }\n   play() {\n      this._paused = false;\n      this._lastTime = performance.now();\n      this._requestAnimationId = requestAnimationFrame(() => this._tick());\n   }\n   pause() {\n      if (this._requestAnimationId) {\n         cancelAnimationFrame(this._requestAnimationId);\n         this._requestAnimationId = null;\n      }\n      this._paused = true;\n   }\n}","let id = 0;\n\nexport default class IdGenerator {\n   static getId() {\n      return id++;\n   }\n}","import IdGenerator from './id-generator';\nimport Status from './status-constants';\n\nconst TARGET_FRAME_RATE = 60;\nconst MIN_ROTATION_PER_FRAME = 1;\n\nexport default class MotionAsset {\n   constructor(target, initTime, duration, unitsPerSecond, rotationPerSecond, motionDirection, rotateToDirection, simulateDepth, spawnLocation, boundingRectangle = null) {\n      this._id = IdGenerator.getId();\n      this._target = target;\n      this._initTimeInMilliseconds = initTime;\n      this._duration = duration;\n      this._unitsPerSecond = unitsPerSecond;\n      this._rotationPerSecond = rotationPerSecond;\n      this._rotationPerFrame = rotationPerSecond / TARGET_FRAME_RATE;\n      this._motionDirection = motionDirection;\n      this._rotateToDirection = rotateToDirection;\n      this._unitsPerFrame = unitsPerSecond / TARGET_FRAME_RATE;\n      this._simulateDepth = simulateDepth;\n      this._spawnLocation = spawnLocation;\n      this._acquireRotationDirection = false;\n      this._destinationX = 0;\n      this._destinationY = 0;\n      this._status = Status.BORN;\n      this._rotationAmount = 0;\n      this._rotationDirection = 1;\n      this._rotationProxy = 0;\n      this._boundingRectangle = boundingRectangle;\n\n      // check rotation per frame value to avoid pathing issues\n      if (this._rotationPerFrame < MIN_ROTATION_PER_FRAME) {\n         this._rotationPerFrame = MIN_ROTATION_PER_FRAME;\n      }\n   }\n   get id() {\n      return this._id;\n   }\n   get target() {\n      return this._target;\n   }\n   get duration() {\n      return this._duration;\n   }\n   get unitsPerSecond() {\n      return this._unitsPerSecond;\n   }\n   get unitsPerFrame() {\n      return this._unitsPerFrame;\n   }\n   set status(status) {\n      this._status = status;\n   }\n   get status() {\n      return this._status;\n   }\n   set initTime(timeInMilliseconds) {\n      this._initTimeInMilliseconds = timeInMilliseconds;\n   }\n   get initTime() {\n      return this._initTimeInMilliseconds;\n   }\n   set x(x) {\n      this._target.x = x;\n   }\n   get x() {\n      return this._target.x;\n   }\n   set y(y) {\n      this._target.y = y;\n   }\n   get y() {\n      return this._target.y;\n   }\n   get width() {\n      return this._target.width || 0;\n   }\n   get height() {\n      return this._target.height || 0;\n   }\n   set rotation(rotation) {\n      if (this._rotateToDirection) {\n         this._target.rotation = rotation;\n      } else {\n         this._rotationProxy = rotation;\n      }\n   }\n   get rotation() {\n      if (this._rotateToDirection) {\n         return this._target.rotation;\n      }\n      return this._rotationProxy;\n   }\n   set destinationX(x) {\n      this._destinationX = x;\n   }\n   get destinationX() {\n      return this._destinationX;\n   }\n   set destinationY(y) {\n      this._destinationY = y;\n   }\n   get destinationY() {\n      return this._destinationY;\n   }\n   get rotationPerSecond() {\n      return this._rotationPerSecond;\n   }\n   get rotationPerFrame() {\n      return this._rotationPerFrame;\n   }\n   get motionDirection() {\n      return this._motionDirection;\n   }\n   set rotateToDirection(bool) {\n      this._rotateToDirection = bool;\n   }\n   get rotateToDirection() {\n      return this._rotateToDirection;\n   }\n   set acquireRotationDirection(acquireRotationDirection) {\n      this._acquireRotationDirection = acquireRotationDirection;\n   }\n   get acquireRotationDirection() {\n      return this._acquireRotationDirection;\n   }\n   set rotationAmount(rotationAmount) {\n      this._rotationAmount = rotationAmount;\n   }\n   get rotationAmount() {\n      return this._rotationAmount;\n   }\n   set rotationDirection(rotationDirection) {\n      this._rotationDirection = rotationDirection;\n   }\n   get rotationDirection() {\n      return this._rotationDirection;\n   }\n   set simulateDepth(simulateDepth) {\n      this._simulateDepth = simulateDepth;\n   }\n   get simulateDepth() {\n      return this._simulateDepth;\n   }\n   set spawnLocation(spawnLocation) {\n      this._spawnLocation = spawnLocation;\n   }\n   get spawnLocation() {\n      return this._spawnLocation;\n   }\n   get boundingRectangle() {\n      return this._boundingRectangle;\n   }\n}","import Rectangle from './rectangle';\nimport {MotionDirection} from './motion-direction';\nimport RandomMotionAdapter from './motion-adapters/random-motion-adapter';\nimport Timer from './timer';\nimport MotionAsset from './motion-asset';\n\nconst MIN_DURATION = 2000;\nconst MIN_UNITS_PER_SECOND = 30;\nconst MIN_ROTATION_SPEED_MODIFIER = 1;\n\nexport default class MotionEngine {\n   constructor(rect = new Rectangle()) {\n      this._boundingRectangle = rect;\n      this._timer = new Timer();\n      this._adaptersMap = {};\n\n      const randomMotionAdapter = new RandomMotionAdapter(this._boundingRectangle);\n      this._timer.addTimeUpdateListener(randomMotionAdapter.update.bind(randomMotionAdapter));\n\n      this._adaptersMap[MotionDirection.CURVE_RANDOM] = randomMotionAdapter;\n   }\n   get paused() {\n      return this._timer.paused;\n   }\n   start() {\n      this._timer.play();\n   }\n   stop() {\n      this._timer.pause();\n   }\n   addAsset({target = null, motionDirection = MotionDirection.CURVE_RANDOM, duration = MIN_DURATION, unitsPerSecond = MIN_UNITS_PER_SECOND, rotationSpeedModifier = MIN_ROTATION_SPEED_MODIFIER, rotateToDirection = true, simulateDepth = false, spawnLocation = 'outside', boundingRectangle = null} = {}) {\n      // TODO: provide way to map transform (x, y, rotation, scale...) properties to target passed\n      const motionAdapter = this._adaptersMap[motionDirection];\n      if (!motionAdapter) {\n         throw new Error(`MotionEngine - No motion adapter found with supplied motion direction of (${motionDirection})`);\n      }\n\n      const rotationSpeed = Math.round(unitsPerSecond * rotationSpeedModifier);\n      const motionAsset = new MotionAsset(target, this._timer.time, duration, unitsPerSecond, rotationSpeed, motionDirection, rotateToDirection, simulateDepth, spawnLocation, boundingRectangle);\n\n      motionAdapter.addAsset(motionAsset);\n\n      return motionAsset;\n   }\n}"],"names":["Rectangle","[object Object]","x","y","width","height","this","_x","_y","_width","_height","_halfWidth","_halfHeight","_eighthWidth","_eighthHeight","value","halfWidth","halfHeight","eighthWidth","eighthHeight","MotionDirection","Object","defineProperties","CURVE_RANDOM","enumerable","RADIANS_CONVERSION","Math","PI","DEGREES_CONVERSION","Mathy","degrees","radians","angleInDegrees","angleInDegrees1","angleInDegrees2","angle1Abs","angle2Abs","angle1Remainder","angle2Remainder","min","rotationDiff","rotation","xDiff","yDiff","currentAngle","normalizeAngle","angle","x1","y1","x2","y2","sqrt","motionAsset","rect","uniqueQuad","randomXRange","max","randomYRange","point","round","random","floor","freeze","BORN","ALIVE","DYING","DEAD","INSIDE_TARGET_AREA","getPositionDelta","positionDelta","destinationX","destinationY","setNewDestinationPoint","boundingRectangle","location","destinationPoint","getRandomPointInsideRect","getRandomPointOutsideRect","resetRotationDirection","acquireRotationDirection","rotationAmount","setAssetStateBasedOnTime","timeInMilliseconds","status","Status","duration","initTime","setScale","simulateDepth","newScale","scaleX","scaleY","setRotation","distance","distanceBetweenTwoPoints","nextRotation","calculatedAngle","acos","calculatedRotation","convertAngleToRotation","getMinAngleDiff","rotationPerFrame","rotationDirection","rotationModifier","setTranslation","abs","unitsPerFrame","currentAngleRadians","convertRotationToAngle","cos","sin","doesAssetNeedNewDestinationPoint","RandomMotionAdapter","_boundingRectangle","_motionAssets","initPoint","spawnLocation","id","keys","forEach","key","Timer","_requestAnimationId","_paused","_currentTime","_lastTime","_timeInMilliseconds","_timeUpdateHandlers","performance","now","every","timeUpdateHandler","requestAnimationFrame","_tick","paused","time","eventHandler","push","cancelAnimationFrame","IdGenerator","TARGET_FRAME_RATE","MIN_ROTATION_PER_FRAME","MotionAsset","target","unitsPerSecond","rotationPerSecond","motionDirection","rotateToDirection","_id","getId","_target","_initTimeInMilliseconds","_duration","_unitsPerSecond","_rotationPerSecond","_rotationPerFrame","_motionDirection","_rotateToDirection","_unitsPerFrame","_simulateDepth","_spawnLocation","_acquireRotationDirection","_destinationX","_destinationY","_status","_rotationAmount","_rotationDirection","_rotationProxy","bool","MIN_DURATION","MIN_UNITS_PER_SECOND","MIN_ROTATION_SPEED_MODIFIER","_timer","_adaptersMap","randomMotionAdapter","addTimeUpdateListener","update","bind","play","pause","rotationSpeedModifier","motionAdapter","Error","rotationSpeed","addAsset"],"mappings":"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"}