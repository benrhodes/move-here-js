{"version":3,"file":"move-here-es5.min.js","sources":["../src/rectangle.js","../src/motion-direction.js","../src/mathy.js","../src/status-constants.js","../src/motion-adapters/random-motion-adapter.js","../src/timer.js","../src/id-generator.js","../src/motion-asset.js","../src/motion-engine.js"],"sourcesContent":["export default class Rectangle {\n   constructor({x = 0, y = -0, width = 0, height = 0} = {}) {\n      this._x = x;\n      this._y = y;\n      this._width = width;\n      this._height = height;\n      this._halfWidth = width / 2;\n      this._halfHeight = height / 2;\n      this._eighthWidth = width / 8;\n      this._eighthHeight = height / 8;\n   }\n\n   set x(value) {\n      this._x = value;\n   }\n\n   get x() {\n      return this._x;\n   }\n\n   set y(value) {\n      this._y = value;\n   }\n\n   get y() {\n      return this._y;\n   }\n\n   set width(value) {\n      this._width = value;\n      this._halfWidth = value / 2;\n      this._eighthWidth = value / 8;\n   }\n\n   get width() {\n      return this._width;\n   }\n\n   set height(value) {\n      this._height = value;\n      this._halfHeight = value / 2;\n      this._eighthHeight = value / 8;\n   }\n\n   get height() {\n      return this._height;\n   }\n\n   get halfWidth() {\n      return this._halfWidth;\n   }\n\n   get halfHeight() {\n      return this._halfHeight;\n   }\n\n   get eighthWidth() {\n      return this._eighthWidth;\n   }\n\n   get eighthHeight() {\n      return this._eighthHeight;\n   }\n}","export const MotionDirection = Object.defineProperties({}, {\n   CURVE_RANDOM: {\n      enumerable: true,\n      value: 'curveRandom'\n   }\n});","const RADIANS_CONVERSION = Math.PI / 180;\nconst DEGREES_CONVERSION = 180 / Math.PI;\n\nexport default class Mathy {\n   static radians(degrees) {\n      return RADIANS_CONVERSION * degrees;\n   }\n   static degrees(radians) {\n      return DEGREES_CONVERSION * radians;\n   }\n   static normalizeAngle(angleInDegrees) {\n      if (angleInDegrees > 360) {\n         while (angleInDegrees > 360) {\n            angleInDegrees -= 360;\n         }\n      } else if (angleInDegrees < -360) {\n         while (angleInDegrees < -360) {\n            angleInDegrees += 360;\n         }\n      }\n      return angleInDegrees;\n   }\n   static getMinAngleDiff(angleInDegrees1, angleInDegrees2) {\n      if (angleInDegrees1 <= 0 && angleInDegrees2 >= 0 || angleInDegrees1 >= 0 && angleInDegrees2 <= 0) {\n         const angle1Abs = angleInDegrees1 > 0.0 ? angleInDegrees1 : -angleInDegrees1;\n         const angle2Abs = angleInDegrees2 > 0.0 ? angleInDegrees2 : -angleInDegrees2;\n         const angle1Remainder = 180 - angle1Abs;\n         const angle2Remainder = 180 - angle2Abs;\n         return Math.min(angle1Remainder + angle2Remainder, angle1Abs + angle2Abs);\n      }\n      const rotationDiff = angleInDegrees1 - angleInDegrees2;\n      return rotationDiff > 0.0 ? rotationDiff : -rotationDiff;\n   }\n   static convertRotationToAngle(rotation, xDiff, yDiff) {\n      let currentAngle;\n\n      // Quad 1\n      if (xDiff >= 0 && yDiff < 0) {\n         currentAngle = 90 + rotation;\n         // Quad 2\n      } else if (xDiff >= 0 && yDiff >= 0) {\n         currentAngle = rotation - 90;\n         // Quad 3\n      } else if (xDiff < 0 && yDiff >= 0) {\n         currentAngle = rotation + 270;\n         // Quad 4\n      } else {\n         currentAngle = rotation + 90;\n      }\n\n      return Mathy.normalizeAngle(currentAngle);\n   }\n   static convertAngleToRotation(angle, xDiff, yDiff) {\n      let rotation;\n\n      // Quad 1\n      if (xDiff >= 0 && yDiff < 0) {\n         rotation = 90 - angle;\n         // Quad 2\n      } else if (xDiff >= 0 && yDiff >= 0) {\n         rotation = 90 + angle;\n         // Quad 3\n      } else if (xDiff < 0 && yDiff >= 0) {\n         rotation = -270 + angle;\n         // Quad 4\n      } else {\n         rotation = 90 - angle;\n      }\n\n      return rotation;\n   }\n   static distanceBetweenTwoPoints(x1, y1, x2, y2) {\n      return Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2));\n   }\n   static getRandomPointInsideRect(motionAsset, rect, uniqueQuad = true) {\n      const randomXRange = {min: 0, max: 0};\n      const randomYRange = {min: 0, max: 0};\n      const point = {x: 0, y: 0};\n\n      if (uniqueQuad) {\n         if (motionAsset.x < rect.x + rect.halfWidth) {\n            randomXRange.min = rect.eighthWidth;\n            randomXRange.max = rect.halfWidth - randomXRange.min;\n         } else {\n            randomXRange.min = -rect.eighthWidth;\n            randomXRange.max = -rect.halfWidth - randomXRange.min;\n         }\n\n         if (motionAsset.y < rect.y + rect.halfHeight) {\n            randomYRange.min = rect.eighthHeight;\n            randomYRange.max = rect.halfHeight - randomYRange.min;\n         } else {\n            randomYRange.min = -rect.eighthHeight;\n            randomYRange.max = -rect.halfHeight - randomYRange.min;\n         }\n      } else {\n         randomXRange.min = rect.x;\n         randomXRange.max = rect.width;\n         randomYRange.min = rect.y;\n         randomYRange.max = rect.height;\n      }\n\n      point.x = motionAsset.x + Math.round(randomXRange.min + Math.random() * randomXRange.max);\n      point.y = motionAsset.y + Math.round(randomYRange.min + Math.random() * randomYRange.max);\n\n      if (point.x > rect.x + rect.width) {\n         point.x = rect.x + rect.width;\n      } else if (point.x < rect.x) {\n         point.x = rect.x;\n      }\n\n      if (point.y > rect.y + rect.height) {\n         point.y = rect.y + rect.height;\n      } else if (point.y < rect.y) {\n         point.y = rect.y;\n      }\n\n      return point;\n   }\n   static getRandomPointOutsideRect(motionAsset, rect) {\n      const point = {x: 0, y: 0};\n      const region = Math.floor(Math.random() * 4);\n      switch (region) {\n         case 0:\n            point.x = rect.x - motionAsset.width;\n            point.y = rect.y + Math.round(Math.random() * rect.height);\n            break;\n         case 1:\n            point.x = rect.x + Math.round(Math.random() * rect.width);\n            point.y = rect.y - motionAsset.height;\n            break;\n         case 2:\n            point.x = rect.x + rect.width + motionAsset.width;\n            point.y = rect.y + Math.round(Math.random() * rect.height);\n            break;\n         case 3:\n            point.x = rect.x + Math.round(Math.random() * rect.width);\n            point.y = rect.y + rect.height + motionAsset.height;\n            break;\n         default:\n            break;\n      }\n\n      return point;\n   }\n}","export default Object.freeze({\n   BORN: 'born',\n   ALIVE: 'alive',\n   DYING: 'dying',\n   DEAD: 'dead'\n});","const OUTSIDE_TARGET_AREA = 'outside';\nconst INSIDE_TARGET_AREA = 'inside';\nconst MIN_SCALE = .5;\nconst MAX_SCALE = 1.5;\n\nimport Mathy from '../mathy';\nimport Status from '../status-constants';\n\nconst getPositionDelta = function(motionAsset) {\n   const positionDelta = {};\n   positionDelta.x = motionAsset.destinationX - motionAsset.x;\n   positionDelta.y = motionAsset.destinationY - motionAsset.y;\n   return positionDelta;\n};\n\nconst setNewDestinationPoint = function(motionAsset, boundingRectangle, location) {\n   let destinationPoint;\n   if (location === INSIDE_TARGET_AREA) {\n      destinationPoint = Mathy.getRandomPointInsideRect(motionAsset, boundingRectangle);\n   } else {\n      destinationPoint = Mathy.getRandomPointOutsideRect(motionAsset, boundingRectangle);\n   }\n\n   motionAsset.destinationX = destinationPoint.x;\n   motionAsset.destinationY = destinationPoint.y;\n};\n\nconst resetRotationDirection = function(motionAsset) {\n   motionAsset.acquireRotationDirection = true;\n   motionAsset.rotationAmount = 0;\n};\n\nconst setAssetStateBasedOnTime = function(motionAsset, timeInMilliseconds, boundingRectangle) {\n   if (motionAsset.status === Status.ALIVE && motionAsset.duration !== -1 && timeInMilliseconds - motionAsset.initTime >= motionAsset.duration) {\n      setNewDestinationPoint(motionAsset, boundingRectangle, OUTSIDE_TARGET_AREA);\n      resetRotationDirection(motionAsset);\n      motionAsset.status = Status.DYING;\n   }\n};\n\nconst setScale = function(motionAsset, boundingRectangle) {\n   if (motionAsset.simulateDepth) {\n      let newScale = MIN_SCALE + (motionAsset.y - boundingRectangle.y) / boundingRectangle.height * (MAX_SCALE - MIN_SCALE);\n\n      if (newScale < MIN_SCALE) {\n         newScale = MIN_SCALE;\n      }\n      if (newScale > MAX_SCALE) {\n         newScale = MAX_SCALE;\n      }\n\n      motionAsset.scaleX = newScale;\n      motionAsset.scaleY = newScale;\n   }\n};\n\nconst setRotation = function(motionAsset, positionDelta) {\n   const distance = Mathy.distanceBetweenTwoPoints(motionAsset.x, motionAsset.y, motionAsset.destinationX, motionAsset.destinationY);\n   if (distance === 0) {\n      return;\n   }\n   let nextRotation = motionAsset.rotation;\n   const calculatedAngle = Math.round(Mathy.degrees(Math.acos(positionDelta.x / distance)));\n   const calculatedRotation = Mathy.convertAngleToRotation(calculatedAngle, positionDelta.x, positionDelta.y);\n   const rotationDiff = Mathy.getMinAngleDiff(calculatedRotation, nextRotation);\n\n   if (rotationDiff <= motionAsset.rotationPerFrame) {\n      nextRotation = calculatedRotation;\n   } else {\n      if (motionAsset.acquireRotationDirection) {\n         motionAsset.acquireRotationDirection = false;\n         if (calculatedAngle < nextRotation) {\n            motionAsset.rotationDirection = -1;\n         } else {\n            motionAsset.rotationDirection = 1;\n         }\n      }\n\n      // determine rotation modifier, this only comes into play when an object has rotated more than\n      // 360 degrees around the destination point.  We need to increase the speed of rotation to it\n      // so it can reach its destination eventually.\n      const rotationModifier = motionAsset.rotationAmount / 360 <= 1 ? 1 : motionAsset.rotationAmount / 360;\n\n      nextRotation += motionAsset.rotationDirection * motionAsset.rotationPerFrame * rotationModifier;\n      nextRotation = Mathy.normalizeAngle(nextRotation);\n   }\n   motionAsset.rotationAmount += Mathy.getMinAngleDiff(motionAsset.rotation, nextRotation);\n   motionAsset.rotation = nextRotation;\n};\n\nconst setTranslation = function(motionAsset, positionDelta) {\n   if (Math.abs(positionDelta.x) < motionAsset.unitsPerFrame && Math.abs(positionDelta.y) < motionAsset.unitsPerFrame) {\n      if (motionAsset.status === Status.DYING) {\n         motionAsset.status = Status.DEAD;\n      }\n      motionAsset.x = motionAsset.destinationX;\n      motionAsset.y = motionAsset.destinationY;\n   } else {\n      const currentAngleRadians = Mathy.radians(Mathy.convertRotationToAngle(motionAsset.rotation, positionDelta.x, positionDelta.y));\n      if (positionDelta.y < 0) {\n         motionAsset.x -= Math.cos(currentAngleRadians) * motionAsset.unitsPerFrame;\n         motionAsset.y -= Math.sin(currentAngleRadians) * motionAsset.unitsPerFrame;\n      } else {\n         motionAsset.x += Math.cos(currentAngleRadians) * motionAsset.unitsPerFrame;\n         motionAsset.y += Math.sin(currentAngleRadians) * motionAsset.unitsPerFrame;\n      }\n   }\n};\n\nconst doesAssetNeedNewDestinationPoint = function(motionAsset) {\n   return motionAsset.x === motionAsset.destinationX && motionAsset.y === motionAsset.destinationY;\n};\n\nexport default class RandomMotionAdapter {\n   constructor(boundingRectangle) {\n      this._boundingRectangle = boundingRectangle;\n      this._motionAssets = {};\n   }\n   addAsset(motionAsset) {\n      let initPoint;\n      if (motionAsset.spawnLocation === 'inside') {\n         initPoint = Mathy.getRandomPointInsideRect(motionAsset, motionAsset.boundingRectangle || this._boundingRectangle, false);\n      } else {\n         initPoint = Mathy.getRandomPointOutsideRect(motionAsset, motionAsset.boundingRectangle || this._boundingRectangle);\n      }\n      motionAsset.x = initPoint.x;\n      motionAsset.y = initPoint.y;\n\n      setNewDestinationPoint(motionAsset, motionAsset.boundingRectangle || this._boundingRectangle, INSIDE_TARGET_AREA);\n      resetRotationDirection(motionAsset);\n      setScale(motionAsset, this._boundingRectangle);\n\n      motionAsset.status = Status.ALIVE;\n\n      this._motionAssets[motionAsset.id] = motionAsset;\n   }\n   update(timeInMilliseconds) {\n      let motionAsset;\n      let positionDelta;\n\n      Object.keys(this._motionAssets).forEach((key) => {\n         motionAsset = this._motionAssets[key];\n\n         setAssetStateBasedOnTime(motionAsset, timeInMilliseconds, motionAsset.boundingRectangle || this._boundingRectangle);\n\n         positionDelta = getPositionDelta(motionAsset);\n         setScale(motionAsset, this._boundingRectangle);\n         setRotation(motionAsset, positionDelta);\n         setTranslation(motionAsset, positionDelta);\n\n         if (doesAssetNeedNewDestinationPoint(motionAsset)) {\n            setNewDestinationPoint(motionAsset, motionAsset.boundingRectangle || this._boundingRectangle, INSIDE_TARGET_AREA);\n            resetRotationDirection(motionAsset);\n         }\n\n         if (motionAsset.status === Status.DEAD) {\n            delete this._motionAssets[key];\n         }\n      });\n   }\n}\n","export default class Timer {\n   constructor() {\n      this._requestAnimationId = null;\n      this._paused = true;\n      this._currentTime = 0;\n      this._lastTime = 0;\n      this._timeInMilliseconds = 0;\n      this._timeUpdateHandlers = [];\n   }\n   _tick() {\n      this._requestAnimationId = null;\n      this._currentTime = performance.now();\n      this._timeInMilliseconds += this._currentTime - this._lastTime;\n      this._lastTime = this._currentTime;\n      this._timeUpdateHandlers.every((timeUpdateHandler) => {\n         return timeUpdateHandler(this._timeInMilliseconds);\n      });\n      if (!this._paused) {\n         this._requestAnimationId = requestAnimationFrame(() => this._tick());\n      }\n   }\n   get paused() {\n      return this._paused;\n   }\n   get time() {\n      return this._timeInMilliseconds;\n   }\n   addTimeUpdateListener(eventHandler) {\n      this._timeUpdateHandlers.push(eventHandler);\n   }\n   play() {\n      this._paused = false;\n      this._lastTime = performance.now();\n      this._requestAnimationId = requestAnimationFrame(() => this._tick());\n   }\n   pause() {\n      if (this._requestAnimationId) {\n         cancelAnimationFrame(this._requestAnimationId);\n         this._requestAnimationId = null;\n      }\n      this._paused = true;\n   }\n}","let id = 0;\n\nexport default class IdGenerator {\n   static getId() {\n      return id++;\n   }\n}","import IdGenerator from './id-generator';\nimport Status from './status-constants';\n\nconst TARGET_FRAME_RATE = 60;\nconst MIN_ROTATION_PER_FRAME = 1;\n\nexport default class MotionAsset {\n   constructor(target, initTime, duration, unitsPerSecond, rotationPerSecond, motionDirection, rotateToDirection, simulateDepth, spawnLocation, boundingRectangle = null) {\n      this._id = IdGenerator.getId();\n      this._target = target;\n      this._initTimeInMilliseconds = initTime;\n      this._duration = duration;\n      this._unitsPerSecond = unitsPerSecond;\n      this._rotationPerSecond = rotationPerSecond;\n      this._rotationPerFrame = rotationPerSecond / TARGET_FRAME_RATE;\n      this._motionDirection = motionDirection;\n      this._rotateToDirection = rotateToDirection;\n      this._unitsPerFrame = unitsPerSecond / TARGET_FRAME_RATE;\n      this._simulateDepth = simulateDepth;\n      this._spawnLocation = spawnLocation;\n      this._acquireRotationDirection = false;\n      this._destinationX = 0;\n      this._destinationY = 0;\n      this._status = Status.BORN;\n      this._rotationAmount = 0;\n      this._rotationDirection = 1;\n      this._rotationProxy = 0;\n      this._boundingRectangle = boundingRectangle;\n\n      // check rotation per frame value to avoid pathing issues\n      if (this._rotationPerFrame < MIN_ROTATION_PER_FRAME) {\n         this._rotationPerFrame = MIN_ROTATION_PER_FRAME;\n      }\n   }\n   get id() {\n      return this._id;\n   }\n   get target() {\n      return this._target;\n   }\n   get duration() {\n      return this._duration;\n   }\n   get unitsPerSecond() {\n      return this._unitsPerSecond;\n   }\n   get unitsPerFrame() {\n      return this._unitsPerFrame;\n   }\n   set status(status) {\n      this._status = status;\n   }\n   get status() {\n      return this._status;\n   }\n   set initTime(timeInMilliseconds) {\n      this._initTimeInMilliseconds = timeInMilliseconds;\n   }\n   get initTime() {\n      return this._initTimeInMilliseconds;\n   }\n   set x(x) {\n      this._target.x = x;\n   }\n   get x() {\n      return this._target.x;\n   }\n   set y(y) {\n      this._target.y = y;\n   }\n   get y() {\n      return this._target.y;\n   }\n   get width() {\n      return this._target.width || 0;\n   }\n   get height() {\n      return this._target.height || 0;\n   }\n   set rotation(rotation) {\n      if (this._rotateToDirection) {\n         this._target.rotation = rotation;\n      } else {\n         this._rotationProxy = rotation;\n      }\n   }\n   get rotation() {\n      if (this._rotateToDirection) {\n         return this._target.rotation;\n      }\n      return this._rotationProxy;\n   }\n   set destinationX(x) {\n      this._destinationX = x;\n   }\n   get destinationX() {\n      return this._destinationX;\n   }\n   set destinationY(y) {\n      this._destinationY = y;\n   }\n   get destinationY() {\n      return this._destinationY;\n   }\n   get rotationPerSecond() {\n      return this._rotationPerSecond;\n   }\n   get rotationPerFrame() {\n      return this._rotationPerFrame;\n   }\n   get motionDirection() {\n      return this._motionDirection;\n   }\n   set rotateToDirection(bool) {\n      this._rotateToDirection = bool;\n   }\n   get rotateToDirection() {\n      return this._rotateToDirection;\n   }\n   set acquireRotationDirection(acquireRotationDirection) {\n      this._acquireRotationDirection = acquireRotationDirection;\n   }\n   get acquireRotationDirection() {\n      return this._acquireRotationDirection;\n   }\n   set rotationAmount(rotationAmount) {\n      this._rotationAmount = rotationAmount;\n   }\n   get rotationAmount() {\n      return this._rotationAmount;\n   }\n   set rotationDirection(rotationDirection) {\n      this._rotationDirection = rotationDirection;\n   }\n   get rotationDirection() {\n      return this._rotationDirection;\n   }\n   set simulateDepth(simulateDepth) {\n      this._simulateDepth = simulateDepth;\n   }\n   get simulateDepth() {\n      return this._simulateDepth;\n   }\n   set spawnLocation(spawnLocation) {\n      this._spawnLocation = spawnLocation;\n   }\n   get spawnLocation() {\n      return this._spawnLocation;\n   }\n   get boundingRectangle() {\n      return this._boundingRectangle;\n   }\n}","import Rectangle from './rectangle';\nimport {MotionDirection} from './motion-direction';\nimport RandomMotionAdapter from './motion-adapters/random-motion-adapter';\nimport Timer from './timer';\nimport MotionAsset from './motion-asset';\n\nconst MIN_DURATION = 2000;\nconst MIN_UNITS_PER_SECOND = 30;\nconst MIN_ROTATION_SPEED_MODIFIER = 1;\n\nexport default class MotionEngine {\n   constructor(rect = new Rectangle()) {\n      this._boundingRectangle = rect;\n      this._timer = new Timer();\n      this._adaptersMap = {};\n\n      const randomMotionAdapter = new RandomMotionAdapter(this._boundingRectangle);\n      this._timer.addTimeUpdateListener(randomMotionAdapter.update.bind(randomMotionAdapter));\n\n      this._adaptersMap[MotionDirection.CURVE_RANDOM] = randomMotionAdapter;\n   }\n   get paused() {\n      return this._timer.paused;\n   }\n   start() {\n      this._timer.play();\n   }\n   stop() {\n      this._timer.pause();\n   }\n   addAsset({target = null, motionDirection = MotionDirection.CURVE_RANDOM, duration = MIN_DURATION, unitsPerSecond = MIN_UNITS_PER_SECOND, rotationSpeedModifier = MIN_ROTATION_SPEED_MODIFIER, rotateToDirection = true, simulateDepth = false, spawnLocation = 'outside', boundingRectangle = null} = {}) {\n      // TODO: provide way to map transform (x, y, rotation, scale...) properties to target passed\n      const motionAdapter = this._adaptersMap[motionDirection];\n      if (!motionAdapter) {\n         throw new Error(`MotionEngine - No motion adapter found with supplied motion direction of (${motionDirection})`);\n      }\n\n      const rotationSpeed = Math.round(unitsPerSecond * rotationSpeedModifier);\n      const motionAsset = new MotionAsset(target, this._timer.time, duration, unitsPerSecond, rotationSpeed, motionDirection, rotateToDirection, simulateDepth, spawnLocation, boundingRectangle);\n\n      motionAdapter.addAsset(motionAsset);\n\n      return motionAsset;\n   }\n}"],"names":["Rectangle","x","y","width","height","_x","_y","_width","_height","_halfWidth","_halfHeight","_eighthWidth","_eighthHeight","value","this","MotionDirection","Object","defineProperties","CURVE_RANDOM","enumerable","RADIANS_CONVERSION","Math","PI","DEGREES_CONVERSION","Mathy","radians","degrees","normalizeAngle","angleInDegrees","getMinAngleDiff","angleInDegrees1","angleInDegrees2","angle1Abs","angle2Abs","angle1Remainder","angle2Remainder","min","rotationDiff","convertRotationToAngle","rotation","xDiff","yDiff","currentAngle","convertAngleToRotation","angle","distanceBetweenTwoPoints","x1","y1","x2","y2","sqrt","getRandomPointInsideRect","motionAsset","rect","uniqueQuad","randomXRange","max","randomYRange","point","halfWidth","eighthWidth","halfHeight","eighthHeight","round","random","getRandomPointOutsideRect","floor","freeze","BORN","ALIVE","DYING","DEAD","setNewDestinationPoint","boundingRectangle","location","destinationPoint","destinationX","destinationY","resetRotationDirection","acquireRotationDirection","rotationAmount","setScale","simulateDepth","newScale","scaleX","scaleY","RandomMotionAdapter","_boundingRectangle","_motionAssets","addAsset","initPoint","spawnLocation","status","Status","id","update","timeInMilliseconds","positionDelta","keys","forEach","key","duration","initTime","setAssetStateBasedOnTime","_this","getPositionDelta","distance","nextRotation","calculatedAngle","acos","calculatedRotation","rotationPerFrame","rotationDirection","rotationModifier","setRotation","abs","unitsPerFrame","currentAngleRadians","cos","sin","setTranslation","doesAssetNeedNewDestinationPoint","Timer","_requestAnimationId","_paused","_currentTime","_lastTime","_timeInMilliseconds","_timeUpdateHandlers","_tick","performance","now","every","timeUpdateHandler","requestAnimationFrame","addTimeUpdateListener","eventHandler","push","play","_this2","pause","cancelAnimationFrame","IdGenerator","getId","TARGET_FRAME_RATE","MIN_ROTATION_PER_FRAME","MotionAsset","target","unitsPerSecond","rotationPerSecond","motionDirection","rotateToDirection","_id","_target","_initTimeInMilliseconds","_duration","_unitsPerSecond","_rotationPerSecond","_rotationPerFrame","_motionDirection","_rotateToDirection","_unitsPerFrame","_simulateDepth","_spawnLocation","_acquireRotationDirection","_destinationX","_destinationY","_status","_rotationAmount","_rotationDirection","_rotationProxy","bool","MotionEngine","_timer","_adaptersMap","randomMotionAdapter","bind","start","stop","rotationSpeedModifier","motionAdapter","Error","rotationSpeed","time","paused"],"mappings":"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"}